#!/usr/bin/env python3
import logging
import numpy as np

from caproto.server import (pvproperty, PVGroup, SubGroup, ioc_arg_parser, run)


logger = logging.getLogger('caproto')


def calculate_k(k0, a, b, period, gap):
    '''
    Calculate undulator strength, K

    Parameters
    ----------
    k0 : float
        Tuning parameter
    a : float
        Tuning parameter
    b : float
        Tuning parameter
    period : float
        Undulator period, in mm
    gap : float, np.array
        Undulator gap, in mm
    '''
    return k0 * np.exp(a * (gap / period) + b * (gap / period) ** 2)


def calculate_photon_energy(electron_energy, period, k):
    '''
    Estimate the energy of photons generated by an undulator (given period and
    K) with electrons at the given energy

    Parameters
    ----------
    electron_energy : float
        Electron energy in GeV
    period : float
        Undulator period, in mm
    k : float
        Undulator K parameter (strength), unitless
    '''
    m_e = 0.0005109989461  # GeV [electron rest mass/energy]
    h = 6.62607004e-34  # Js [Planck's constant]
    e = 1.6021766208e-19  # C [electron charge]
    c = 299792458  # m/s, speed of light
    return ((2. * (electron_energy / m_e) ** 2 * h * c) /
            (e * period * 1e-3 * (1 + k ** 2 / 2.))
            )


class HeartbeatGroup(PVGroup):
    heartbeat = pvproperty(value=0, mock_record='bo', read_only=True,
                           doc='The heartbeat signal')
    beat_id = pvproperty(value=0, mock_record='longin', read_only=True,
                         doc='Always-increasing heartbeat ID')
    beat_pattern = pvproperty(value=[0, 1, 1,
                                     1, 1, 1],
                              max_length=1024,
                              doc='0 to skip beat, non-zero to beat')

    @heartbeat.scan(period=0.5, use_scan_field=True)
    async def heartbeat(self, instance, async_lib):
        beat_id = self.beat_id.value + 1
        await self.beat_id.write(beat_id)
        beat_pattern = self.beat_pattern.value
        if not beat_pattern[beat_id % len(beat_pattern)]:
            return

        await instance.write(beat_id % 2)

    @beat_pattern.startup
    async def beat_pattern(self, instance, async_lib):
        scan = self.heartbeat.fields['SCAN']
        try:
            await scan.write('.5 second')
        except TypeError:
            # TODO: old caproto compat
            scan._data['value'] = scan.enum_strings.index('.5 second')


class UndulatorInfoGroup(PVGroup):
    k0 = pvproperty(value=0.0, read_only=True)
    a = pvproperty(value=0.0, read_only=True)
    b = pvproperty(value=0.0, read_only=True)
    period = pvproperty(value=0, read_only=True)


class BeamParametersGroup(PVGroup):
    undulator_info = SubGroup(UndulatorInfoGroup, prefix='')

    rate = pvproperty(
        value=10,
        doc='Repetition rate',
        units='Hz'
    )

    charge = pvproperty(
        value=10,
        mock_record='longin',
        units='pC',
        doc='Bunch charge'
    )

    gap = pvproperty(
        value=10.,
        doc='Undulator gap',
        mock_record='ai',
        units='mm',
    )

    k = pvproperty(
        value=0.,
        doc='Undulator strength (K)',
        mock_record='ai',
        units='n/a',
    )

    electron_energy = pvproperty(
        value=10,
        doc='Electron energy',
        read_only=True,
        units='GeV'
    )

    photon_energy = pvproperty(
        value=10,
        doc='Photon energy',
        read_only=True
    )

    @gap.putter
    async def gap(self, instance, value):
        k = calculate_k(
            k0=self.undulator_info.k0.value, a=self.undulator_info.a.value,
            b=self.undulator_info.b.value,
            period=self.undulator_info.period.value,
            gap=value,
        )

        await self.k.write(k)

        photon_energy = calculate_photon_energy(
            electron_energy=self.electron_energy.value,
            period=self.undulator_info.period.value,
            k=k)
        await self.photon_energy.write(photon_energy)


class BeamlineGroup(PVGroup):
    heartbeat = SubGroup(HeartbeatGroup, prefix='')
    beam_params = SubGroup(BeamParametersGroup, prefix='')

    def __init__(self, *args, params, **kwargs):
        super().__init__(*args, **kwargs)

        lower_gap, upper_gap = params['gap_range']
        self.beam_params.gap._data.update(
            lower_ctrl_limit=lower_gap,
            upper_ctrl_limit=upper_gap
        )

        lower_energy, upper_energy = params['electron_energy_range']
        self.beam_params.electron_energy._data.update(
            lower_ctrl_limit=lower_energy,
            upper_ctrl_limit=upper_energy,
        )

        und_info = self.beam_params.undulator_info
        for param in ('k0', 'a', 'b', 'period'):
            getattr(und_info, param)._data['value'] = params[param]


class AcceleratorGroup(PVGroup):
    # hxu assuming copper line (SCRF line is slightly different, gap-wise)
    hxu = SubGroup(BeamlineGroup,
                   params=dict(k0=9.471,
                               a=-5.131, b=1.878,
                               period=26.,
                               gap_range=(7.2, 19),
                               electron_energy_range=(2.5, 15.0),
                               )
                   )
    sxu = SubGroup(BeamlineGroup,
                   params=dict(k0=13.997,
                               a=-5.131, b=1.878,
                               period=39.,
                               gap_range=(7.2, 20),
                               electron_energy_range=(3.6, 4.0),
                               )
                   )


if __name__ == '__main__':
    ioc_options, run_options = ioc_arg_parser(
        default_prefix='TST:PMPS:ACCEL:',
        desc='Accelerator IOC simulator for PMPS',
    )

    ioc = AcceleratorGroup(**ioc_options)
    run(ioc.pvdb, **run_options)
